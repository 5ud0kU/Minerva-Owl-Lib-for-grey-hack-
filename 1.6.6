//Minerva Owl Lib Open Source Package for Grey Hack 0.7.3x, coded by Chrome https://steamcommunity.com/id/01043477120/.
//The package is a bundle of many functions.You can use this script for learning , personal usage.If you add
//or remove code in view to integrated it to your own public project, in this case please mention wich part belong
//to my personal work and intellectual integrity.

//  /¤v¤\ 
//  |/ \|
//  |/ \|  Minerva Owl Lib 1.6.6
//   ,|.
//          + - Math Lib
//		    |+ - vector2-4
//  	    |+ - decimalToHex
//          |+ - decimalToBinary
//          |+ - median
//          |+ - average
//          |+ - pourcent
// 		    + - String Lib
//          |+ - reverseString
//          |+ - stringToDecimal
//		    |+ - stringToHex
//          |+ - stringToList
//          + - Graph Lib
//          |+ - rgb
//          |+ - color
//          |+ - Size
//          |+ - italic
//          |+ - bold
//          |+ - underline
//          |+ - drawLine
//          |+ - align
//          |+ - spacing
//          |+ - font
//          |+ - indent
//          |+ - margin
//          |+ - mark
//          |+ - sprite
//          |+ - strike
//          |+ - video engine
//			|+ - animator
//          |+ - animationPart
//			|+ - displayFlush
//  		|+ - displayResolution
//          |+ - bgColor
//          |+ - lastFrame
//          |+ - displayRate
//          + - FileManagement Lib
//          |+ - scanDrive
//          |+ - stream
//          |+ - write
//          |+ - read
//          |+ - flush
//          + Meta Lib
//          |+ - dump
//          |+ - decrypt
//          + Net Lib
//          |+ - scan_wifi
//          |+ - ack
//          |+ - interface
//          |+ - netconfig
//          |+ - toNetStr
//          |+ - addSession
//          |+ - closeSession
//          |+ - backSessions
//          |+ - connect
//          + Algo Lib
//          |+ - swap
//          |+ - compare
//          |+ - min
//          |+ - max
//          |+ - permute


//Dependencies.
//The dependencies are loaded in /lib, where they sould be.

print("Powered by MLL 1.6.6 , please wait while loading dependencies");

__reserved_metaxploit = "";
__reserved_crypto = "";
__reserved_apt = "";

if typeof(get_shell.host_computer.File("/lib")) == "file" then
	libs = get_shell.host_computer.File("/lib").get_files;
	
	if libs.len > 0 then
		for i in range(0,libs.len -1)
			if libs[i].name == "metaxploit.so" then
				print("loading metaxploit ..." + libs[i].path);
				__reserved_metaxploit = include_lib(libs[i].path);
			else if libs[i].name == "crypto.so" then 
				print("loading crypto ..." + libs[i].path);
				__reserved_crypto = include_lib(libs[i].path);
			else if libs[i].name == "aptclient.so" then 
				print("loading aptclient ..." + libs[i].path);
				__reserved_apt = include_lib(libs[i].path);
			end if
		end for
	end if
end if

print("loading complete , launching application...");
wait(0.3);
clear_screen;

//MATH LIB.

//Vectors 2d, 3d, 4d.
//Vectors are simple list.They act as holders, example given : the position of a point in a grid.
//Well used , they can speed up some processing in math.
__vector2 = function(x,y)
	if typeof(x) != "number" then return "error : vector2 -> x not a number";
	if typeof(y) != "number" then return "error : vector2 -> y not a number";
	return [x,y];
end function

__vector3 = function(x,y,z)
	if typeof(x) != "number" then return "error : vector3 -> x not a number";
	if typeof(y) != "number" then return "error : vector3 -> y not a number";
	if typeof(z) != "number" then return "error : vector3 -> z not a number";
	return [x,y,z];
end function

__vector4 = function(x,y,z,w)
	if typeof(x) != "number" then return "error : vector4 -> x not a number";
	if typeof(y) != "number" then return "error : vector4 -> y not a number";
	if typeof(z) != "number" then return "error : vector4 -> z not a number";
	if typeof(w) != "number" then return "error : vector4 -> w not a number";
	return [x,y,z,w];
end function

//Decimal to hex converter.
//The function convert a decimal value to a hex into a given string.Example Math.decimalToHex(10,"") , will return the hex value of 10.
//Important: If you have a decimal string, remember that this function accept one decimal at the time.

__reserved_hex_string = ""; 
__DecimalToHex = function(x,z)
	if typeof(x) != "number" then return "error : decimal to hex -> x not a number";
	
	remainder = x% 16; 
	sum = x / 16;
	hex = z;
	
	if remainder == 10 then remainder = "A";
	if remainder == 11 then remainder = "B";
	if remainder == 12 then remainder = "C";
	if remainder == 13 then remainder = "D";
	if remainder == 14 then remainder = "E";
	if remainder == 15 then remainder = "F";
	
	hex = hex + str(remainder);
	if str(sum).indexOf(".") != null then
		sum = str(sum).split(".")[0].to_int;
	end if
	
	if sum > 0 then 
		__DecimalToHex(sum,hex);
	else
		globals.__reserved_hex_string = __reverseString(hex);
	end if
	return __reserved_hex_string;
end function

//Pourcent.
//This function simply return a pourcentage.
__pourcent = function(x,y)
	if typeof(x) != "number" then return "error : pourcent -> x expected int.";
	if typeof(x) != "number" then return "error : pourcent -> y expected int.";
	pourcent = (x/y) * 100;
	return pourcent;
end function

//Median.
//This function return the median element of a list.
__median = function(x)
	if typeof(x) != "list" then return "error : median -> x expected list.";
	n = x.len;
	median = x[(n + 1)/2];
	return median;
end function

//Average.
//This function return the average of a series of integer in a list.
__average = function(x)
	if typeof(x) != "list" then return "error : average -> x list expected.";
	sum = 0;
	elements = 0;
	for i in range(0,x.len -1)
		if typeof(x[i]) != "number" then return "error :  average -> x[i] expected integer.";
		sum = sum + x[i];
		elements = elements + 1;
	end for
	
	average = sum/elements;
	return average;
end function

//decimalToBinary
//This function convert a decimal to binary then return the result.It use the divided by 2 method.
__reserved_binary_string = "";
__decimalToBinary = function(x,z)
	if typeof(x) != "number" then return "error : decimal to binary -> x int expected.";
	
	remainder = x% 2;
	sum = x / 2;
	binary = z;
	
	binary = binary + str(remainder);
	if str(sum).indexOf(".") != null then
		sum = str(sum).split(".")[0].to_int;
	end if 
	
	if sum == 1 or sum == 0 then
		if sum == 0 then binary = binary + "0";
		if sum == 1 then binary = binary + "1";
		globals.__reserved_binary_string = __reverseString(binary).to_int;
		return __reserved_binary_string;
	else
		//Here we put a special return cause its like that.No kidding, apparently
		//is due because its a recursive function.As the modo on discord say.Permit 
		//me to doubt of it as decimal to hex function dont use it and return normaly.
		//Dont remove that return or it will bug.
		return __decimalToBinary(sum,binary);
	end if
end function

//The referencer.
Math = new {};
Math.vector2 = @__vector2;
Math.vector3 = @__vector3;
Math.vector4 = @__vector4;
Math.decimalToHex = @__DecimalToHex;
Math.decimalToBinary = @__decimalToBinary;
Math.pourcent = @__pourcent;
Math.median = @__median;
Math.average = @__average;

//STRING LIB.

//Reverse string.
//Simply reverse a string.
__reserved_reverse_string = "";
__reverseString = function(x)
	if typeof(x) != "string" then return "error : reverse string -> x expected string.";
	string = [];
	for i in range(0,x.len -1)
		string.push(x[i]);
	end for
	string.reverse;
	globals.__reserved_reverse_string = string.join("");
	return __reserved_reverse_string;
end function

//String to decimal.
//Simply convert a string to decimal.
__stringToDecimal = function(x)
	if typeof(x) != "string" then return "error : string to decimal -> x expected string.";
	decString = "";
	for i in range(0,x.len -1)
		decString = decString + code(x[i]);
		if i < x.len -1 then decString = decString + ":";
	end for
	return decString;
end function

//String to hex.
//Simply convert a string to hex , using Math lib.
__stringToHex = function(x)
	if typeof(x) != "string" then return "error : string to hex -> x expected string.";
	hexString = "";
	for i in range(0,x.len -1)
		hexString = hexString + __DecimalToHex(code(x[i]),"");
		if i < x.len -1 then hexString = hexString + ":";
	end for
	return hexString;
end function

//String to list.
//Simply convert a string to a char list.
__stringToList = function(x)
	if typeof(x) != "string" then return "error : string to list -> x expected string.";
	list = [];
	for i in range(0,x.len -1)
		list.push(x[i]);
	end for
	return list;
end function

//The referencer.
String = new {};
String.reverseString = @__reverseString;
String.stringToHex = @__stringToHex;
String.stringToDecimal = @__stringToDecimal;
String.stringToList = @__stringToList;

//GRAPH LIB.

//RGB.
//This function return the hex tag of the given rgb value, in a vector form.
//Exemple Graph.rgb(Math.vector3(135,22,55)) , this return the color to in hex format.
__reserved_hex_tag = "";
__RGB = function(x)
	if typeof(x) != "list" then return "error : rgb -> x expected list.";
	if x.len != 3 then return "error : rgb -> x expected 3 len."
	hexTag = "";
	for i in range(0,x.len -1)
		if typeof(x[i]) != "number" then return "error : rgb -> x[i] not a number"
		hexTag = hexTag + __DecimalToHex(x[i],"");
	end for
	
	if hexTag.len < 6 then
		hexTag = "#0" + hexTag;
	else
		hexTag = "#" + hexTag;
	end if
	
	__reserved_hex_tag = hexTag;
	return __reserved_hex_tag;
end function

//Color.
//This function return the given text enquote of <color=y> </color> tags, with the given hex colors.
__color = function(x,y)
	color = "<color=" + y + ">" + x + "</color>";
	return color;
end function

//Size.
//This function return the given text enquote of <size=y> </size> tags, with the given size.
__Size = function(x,y)
	if typeof(y) != "number" then return "error : size y not a number.";
	return "<size=" + y + ">" + x + "</size>";
end function

//Italic.
//This function return the given text enquote of <italic> </italic> tags.
__italic = function(x)
	italic = "<i>" + x + "</i>";
	return italic;
end function

//Bold.
//This function return the given text enquote of <bold> </bold>.
__bold = function(x)
	bold = "<b>" + x + "</b>";
	return bold;
end function

//Underline.
//This function return the text underlined.
__underline = function(x)
	return "<u>" + x + "</u>";
end function

//drawLine.
//This function draw a line with the len according to the z value.
__drawLine = function(x,y)
	if typeof(x) != "string" then return "error : draw line -> x expected string.";
	if typeof(y) != "number" then return "error : draw line -> y expected int.";
	for i in range(1,y)
		x = x + char(95);
	end for
	return __underline(x) ;
end function

//align.
//This function align the text according to the z value.left , right & center
__align = function(x,z)
	if z != "center" and z != "right" and z != "center" then return "error : align -> z expected left,right or center.";
	return "<align=" + z + ">" + x + "</align>";
end function

//spacing.
//This function space the text to the z value.
//Example Graph.spacing("text","1em");
__spacing = function(x,z)
	return "<cspace=" + z + ">" + x + "</cspace>";
end function

//font.
//This function will apply the given font to the given text.
//Here some available font found:
//SourceCodePro-Regular SDF
//LiberationSans SDF
__font = function(x,z)
	return "<font=" + z + ">" + x + "</font>";
end function

//Indent.
//This function return the text with indented.Z take the value as a pourcentage.
__indent = function(x,z)
	return "<indent=" + z + ">" + x + "</indent>";
end function

//Margin.
//This function return the text with the value of z as margin.
__margin = function(x,z)
	return "<margin=" + z + ">" + x + "</margin>";
end function

//Mark.
//This function return the text marked by the hex color of the z value.
__mark = function(x,z)
	return "<mark=" + z + ">" + x + "</mark>";
end function

//Sprite.
//This function is mysterious return the sprite according the given id:int.
//Atm only index 0 as be found.What a mystery.
__sprite = function(x)
	return "<sprite=" + x + ">";
end function

//Strike.
//This function strike the text and return it.
__strike = function(x)
	return "<s>" + x + "</s>";
end function

//The video engine.
//The function manipulate a grid with black pixel in it.When you turn on a pixel.Dont forget to turn it off, if you dont want it appear in the next frame.
//Its the same for the grid dont forget to reinitialize the pixels example changing a scene.
__reserved_video_buffer = {"queud":[],"lastFrame":""};
__reserved_video_display = {"grid":[8,8],"content":[],"bg":"<mark=#000000>x</mark>","rate":0.6}; //default 8x8
__reserved_video_switch = true;
__videoEngine = function(buf,dis)
	clear_screen;
	while (__reserved_video_buffer.queud.len != 0)
		if __reserved_video_display.content.len == 0 then
			yaxis = [];
			for i in range(1,__reserved_video_display.grid[0])
				xaxis = [];
				for e in range(1,__reserved_video_display.grid[1])
					xaxis.push((__reserved_video_display.bg));
				end for
				yaxis.push(xaxis);
			end for
			globals.__reserved_video_display.content = yaxis;
		end if
		
		globals.__reserved_video_display.content[__reserved_video_buffer.queud[0].position[0] -1][__reserved_video_buffer.queud[0].position[1] -1] = __reserved_video_buffer.queud[0].value;
		frame = "";
		for i in range(0,__reserved_video_display.content.len -1)
			for e in range(0,__reserved_video_display.content[i].len -1)
				if __reserved_video_display.content[i][e] == "" then globals.__reserved_video_display.content[i][e] = __reserved_video_display.bg;
			end for
			frame = frame + char(10) + __reserved_video_display.content[i].join("");
		end for
		if __reserved_video_buffer.queud.len == 1 then
			globals.__reserved_video_buffer.lastFrame = frame;
			print(frame);
			wait(__reserved_video_display.rate);
		end if
		__reserved_video_buffer.queud.remove(0);
	end while
	return;
end function

//The animator play the given animation.
__animator = function(x)
	for i in range(0,x.len -1)
		__reserved_video_buffer.queud.push(x[i]);
	end for	
	return __videoEngine(__reserved_video_buffer,__reserved_video_display);
end function

//The animation part is the variable that store the data of the pixel in the grid.If the value of a 
//pixel "" then the pixel become a black pixel.
__animationPart = function(x,y)
	if typeof(x) != "string" then return "error : animation part -> x expected string.";
	if typeof(y) != "list" then return "error : animation part -> y expected number.";
	animationString = {};
	animationString.value = x;
	animationString.position = y;
	return animationString;
end function

//display flush, reset all pixels in the grid.
__displayFlush = function()
	globals.__reserved_video_display.content = [];
	return;
end function

//The function set the default grid color, named background.
__bgColor = function(x)
	globals.__reserved_video_display.bg = "<mark=" + x + ">x</mark>";
	return;
end function

//display resolution change the size of the grid , by default its 8*8.
__displayResolution = function(x,y)
	if typeof(x) != "number" then return "error : display resolution -> x expected number.";
	if typeof(y) != "number" then return "error : display resolution -> y expected number.";
	globals.__reserved_video_display.grid[0] = x;
	globals.__reserved_video_display.grid[1] = y;
	return;
end function

//return the last frame processed.
__lastFrame = function()
	return globals.__reserved_video_buffer.lastFrame;
end function

__displayRate = function(x)
	if typeof(x) != "number" then return "error : display rate -> x expected number.";
	return globals.__reserved_video_display.rate(x);
end function

//The referencer.
Graph = new {};
Graph.rgb = @__RGB;
Graph.color = @__color;
Graph.Size = @__Size;
Graph.italic = @__italic;
Graph.bold = @__bold;
Graph.underline = @__underline;
Graph.drawLine = @__drawLine;
Graph.align = @__align;
Graph.spacing= @__spacing;
Graph.font = @__font;
Graph.indent = @__indent;
Graph.margin = @__margin;
Graph.mark = @__mark;
Graph.sprite = @__sprite;
Graph.strike = @__strike;
Graph.animator = @__animator;
Graph.animationPart = @__animationPart;
Graph.displayFlush = @__displayFlush;
Graph.displayResolution = @__displayResolution;
Graph.bgColor = @__bgColor;
Graph.lastFrame = @__lastFrame;
Graph.displayRate = @__displayRate;

//FILEMANAGEMENT LIB.

//Scan drive.
//This function scan the entire drive and return it as an object.
__reserved_user_files = [];
__reserved_user_folders = [];
__scan_drive = function(x)
	__scan_files = function(y)
		for e in range(0,y.get_files.len -1)
			if y.get_files.len > 0 then
				globals.__reserved_user_files.push(y.get_files[e]);
			end if
		end for
	end function
	
	__scan_folders = function(z)
		if typeof(z) != "file" then return "error : scan drive path not exist";
		for i in range(0,z.get_folders.len -1)
			if z.get_folders.len > 0 then
				globals.__reserved_user_folders.push(z.get_folders[i]);
				__scan_files(z.get_folders[i]);
				__scan_folders(z.get_folders[i]);
			end if
		end for
	end function
	
	__scan_folders(get_shell.host_computer.File(x));
	drive = new {};
	drive.files = __reserved_user_files;
	drive.folders = __reserved_user_folders;
	
	return drive;
end function

//Stream.
//This function is used to read/write files.Example FileSystem.stream("out","/lib/text.txt");
__reserved_stream = {"read":false,"write":false,"file":""};
__stream = function(x,y)
	if __reserved_stream.read == false and __reserved_stream.write == false then
		if x == "out" then globals.__reserved_stream.write = true;
		if x == "in" then globals.__reserved_stream.read = true;
		if __reserved_stream.read == false and __reserved_stream.write == false then return "error : stream unknown type , available in or out."; 
		globals.__reserved_stream.file = get_shell.host_computer.File(y);
		if typeof(__reserved_stream.file) != "file" then
			if y.indexOf("/") == null then 
				get_shell.host_computer.touch(current_path,y);
			else 
				directory = "/" + y.split("/")[1:y.split("/").len - 1].join("/");
				filename = y.split("/")[y.split("/").len - 1];
				get_shell.host_computer.touch(directory,filename);
			end if
			if typeof(get_shell.host_computer.File(y)) != "file" then return "error : stream file -> y was unable to create the file.";
			if typeof(get_shell.host_computer.File(y)) == "file" then globals.__reserved_stream.file = get_shell.host_computer.File(y);
		end if
		return;
	else
		return "Buffer in use.";
	end if
end function

//Write.
//This function is used to write on the current stream.By this mean a out stream should be opened.
__write = function(x)
	if __reserved_stream.write == true then
		if typeof(__reserved_stream.file) != "file" then return "error : write -> file not exist";
		__reserved_stream.file.set_content(x);
		return;
	else
		return "Buffer currently closed.";
	end if
end function

//Read.
//This function is used to read the content of a in stream.
__read = function()
	if __reserved_stream.read == true then
		if typeof(__reserved_stream.file) != "file" then return "error : write -> file not exist";
		return __reserved_stream.file.get_content;
	else
		return "Buffer currently closed.";
	end if
end function

//Flush.
//This function close the stream.
//Important: Only one stream can live at the time.
__flush = function()
	globals.__reserved_stream.read = false;
	globals.__reserved_stream.write = false;
	globals.__reserved_stream.file = "";
end function

//The referencer.
FileSystem = new {};
FileSystem.scanDrive = @__scan_drive;
FileSystem.stream = @__stream;
FileSystem.write = @__write;
FileSystem.read = @__read;
FileSystem.flush = @__flush;

//Meta Lib.

//Dump
//This function scan the lib at the given addrs/port and return all the mems and cve into list.
__dump = function(x,y)
	if typeof(y) != "number" then return "error : dump -> y expected number.";
	target = __reserved_metaxploit.net_use(x,y);
	if typeof(target) != "NetSession" then return "error : dump -> net session failed.";
	if typeof(__reserved_metaxploit) != "MetaxploitLib" then return "error : dump metaxploit not found in /lib";
	target_lib = target.dump_lib;
	target_scan = __reserved_metaxploit.scan(target_lib);
	target_exploits = [];
	for i in range(0,target_scan.len -1)
		target_exploits.push({"mem":target_scan[i],"cve":__reserved_metaxploit.scan_address(target_lib,target_scan[i])});
	end for
	return target_exploits;
end function

//Decrypt
//This function try to decrypt a given user:pass hash format.Example Meta.decrypt("user:hash") , this will return the pass is it succeed.
__decrypt = function(x)
	password = __reserved_crypto.decipher(x.split(":")[1]);
	return password;
end function

//The referencer.
Meta = new {};
Meta.dump = @__dump;
Meta.decrypt = @__decrypt;

//Net Lib.

//Scan wifi.
//This function scan the wifi on the given interface and store in a list.
__scan_wifi = function(x)
	networks = get_shell.host_computer.wifi_networks(x);
	return networks;
end function

//Ack 
//This function capture packets of the given wifi.It take 3 arguments as a single string.Example Net.Ack("bssid,essid,maxAck").
__ack = function(x)
	bid = x.split(",")[0];
	eid = x.split(",")[1];
	ack = x.split(",")[2].to_int;
	
	__reserved_crypto.aireplay(bid,eid,ack);
	return;
end function

//Interface.
//This function work the same as crypto.airmon, its theres for aestetic.
__interface = function(x,y)
	__reserved_crypto.airmon(x,y);
	return;
end function

//NetConfig 
//This function return info in a list about the current network information.
__netconfig = function()
	config = [get_router.essid_name,get_router.bssid_name,get_shell.host_computer.network_gateway,get_shell.host_computer.local_ip,get_shell.host_computer.public_ip,whois(get_shell.host_computer.public_ip)];
	return config;
end function

//toNetStr.
//This function is used to convert a single element of a list returned by scan_wifi.
//You can always make it manualy.

__toNetStr = function(x,y)
	data = x.split(" ");
	if data.len != 3 then return "error : net to string -> x the string format is not recognized.";
	bid = data[0];
	eid = data[2];
	ack = y;
	netString = bid + "," + eid + "," + ack;
	return netString;
end function

//addSession.
//This function allow you to background a network session.It store it in a list as a network object.
//Note: The session set is design to let the user having multiple sessions from one point.Like this 
//You can free up space in coding using one main variable to create connection
//.It is also useful to create dynamic connections bot etc.You can also used
//Net.connect(ip,user,port,pass) like connect_service. Net.connect will do all the work for you, aswell
//removing the initial var.The only thing need if Net.connect is used , is to catch the session
//from the backsession function.By iterating trough the data of the elements you will find your 
//connection.
__reserved_backsession = [];
__addSession = function(x)
	if typeof(x) != "shell" then return "error : background session -> x shell expected.";
	session = new {};
	session.ip = x.host_computer.public_ip;
	session.lan = x.host_computer.local_ip;
	session.gateway = get_router(x.host_computer.public_ip).local_ip;
	session.shell = x;
	session.id = __reserved_backsession.len ;
	globals.__reserved_backsession.push(session);
	return;
end function

//closeSession.
//This function allow you to close a background session.
__closeSession = function(x)
	if typeof(x) != "number" then return "error : close session -> x int expected.";
	globals.__reserved_backsession.remove(x);
	return;
end function

//backsession.
//This function return all the backgroundSession list.
__backsessions = function()
	return __reserved_backsession;
end function

//connect.
//This function is used to connect to various service.The connection is stored in backsession and are accessible in backsession function.
//Net.connect(ip,port,user,pass);
//Note if the connection fail, it will not appear in the backgroundSession list as no connection occured.
__connect = function(x,y,z,w)
	if typeof(y) != "number" then return "error : connect -> y int expected";
	__addSession(get_shell.connect_service(x,y,z,w));
	return;
end function

//The referencer.
Net = new {};
Net.scan_wifi = @__scan_wifi;
Net.ack = @__ack;
Net.interface = @__interface;
Net.netconfig = @__netconfig;
Net.toNetStr = @__toNetStr;
Net.addSession = @__addSession;
Net.closeSession = @__closeSession;
Net.backSessions = @__backsessions;
Net.connect = @__connect;

//AlgoLib

//This function is used to swap to values in a list of size two.
__swap =  function(x)
	if typeof(x) != "list" then return "error : swap -> x list expected.";
	if x.len != 2 then return "error : swap -> x len 2 expected.";
	a = x[0];
	b = x[1];
	x[0] = b;
	x[1] = a;
	return x;
end function

//Compare.
//The compare function is use to know if x > or < or == y.
__compare = function(x,y)
	if x > y then return ">"; //62
	if x < y then return "<"; //60
	if x == y then return "=="; //61
end function

//Max.
//This function is used to know the max of two given values.
__max = function(x)
	if typeof(x) != "list" then return "error : max -> x list expected."
	if x.len != 2 then return "error : max -> x len 2 expected."
	if typeof(x[0]) == "number" and typeof(x[1]) == "number" then
		max = __compare(x[0],x[1]);
		if max == ">" or max == "==" then return x[0];
		if max == "<" then return x[1];
	else if typeof(x[0]) == "string" and typeof(x[1]) == "number" then
		max = __compare(code(x[0]),x[1]);
		if max == ">" or max == "==" then return x[0];
		if max == "<" then return x[1];
	else if typeof(x[0]) == "number" and typeof(x[1]) == "string" then
		max = __compare(x[0],code(x[1]));
		if max == ">" or max == "==" then return x[0];
		if max == "<" then return x[1];
	else if typeof(x[0]) == "string" and typeof(x[1]) == "string" then
		max = __compare(code(x[0]),code(x[1]));
		if max == ">" or max == "==" then return x[0];
		if max == "<" then return x[1];
	end if
	return;
end function

//Min.
//This function is used to know the min of two given valuess.
__min = function(x)
	if typeof(x) != "list" then return "error : min -> x list expected.";
	if x.len != 2 then return "error : min -> x len 2 expected.";
	if typeof(x[0]) == "number" and typeof(x[1]) == "number" then
		min = __compare(x[0],x[1]);
		if min == ">" or min == "==" then return x[1];
		if min == "<" then return x[0];
	else if typeof(x[0]) == "string" and typeof(x[1]) == "number" then
		min = __compare(code(x[0]),x[1]);
		if min == ">" or min == "==" then return x[1];
		if min == "<" then return x[0];
	else if typeof(x[0]) == "number" and typeof(x[1]) == "string" then
		min = __compare(x[0],code(x[1]));
		if min == ">" or min == "==" then return x[1];
		if min == "<" then return x[0];
	else if typeof(x[0]) == "string" and typeof(x[1]) == "string" then
		min = __compare(code(x[0]),code(x[1]));
		if min == ">" or min == "==" then return x[1];
		if min == "<" then return x[0];
	end if
	return;
end function

//Permute.
//This function is used to permute strings.

__permute = function(x,y);
	if typeof(x) != "string" then return "error : permute -> x string expected."
	if y == [] then y.push(x);
	
	s0 = __stringToList(x);
	s1 = s0[0];
	s2 = s0[1:s0.len].join("");
	
	swap = __swap([s1,s2]).join("");
	revs = __reverseString(swap);
	
	y.push(swap);
	y.push(revs);
	
	if y.indexOf(y[0],1) != null then return y[1:y.len];
	if y.indexOf(y[0],1) == null then return __permute(swap,y);
end function

Algo = new {};
Algo.swap = @__swap;
Algo.compare = @__compare;
Algo.max = @__max;
Algo.min = @__min;
Algo.permute = @__permute;
