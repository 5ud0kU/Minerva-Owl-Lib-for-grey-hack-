// Minerva Owl Lib Open Source Package for Grey Hack 0.7.3x, coded by Chrome https://steamcommunity.com/id/01043477120/.
// The package is a bundle of many functions.You can use this script for learning , personal usage.If you add
// or remove code in view to integrated it to your own public project, in this case please mention wich part belong
// to my personal work and intellectual integrity.

//  /¤v¤\
//  |/ \|
//  |/ \|  Minerva Owl Lib 1.9.6
//   ,|.

//			+ - Libs
//			|+ - load_dependencies
//			|+ - metaxploit
//			|+ - crypto
//			|+ - aptclient
//			|+ - libmail
//          + - Math Lib
//		    |+ - vector2-4
//  	    |+ - decimalToHex
//          |+ - decimalToBinary
//          |+ - median
//          |+ - average
//          |+ - pourcent
//          |+ - binaryToDecimal
// 		    + - String Lib
//          |+ - reverseString
//          |+ - stringToDecimal
//		    |+ - stringToHex
//          |+ - stringToList
//          |+ - replace
//          |+ - cut
//          + - Graph Lib
//          |+ - rgb
//          |+ - color
//          |+ - Size
//          |+ - italic
//          |+ - bold
//          |+ - underline
//          |+ - drawLine
//          |+ - align
//          |+ - spacing
//          |+ - font
//          |+ - indent
//          |+ - margin
//          |+ - mark
//          |+ - sprite
//          |+ - strike
//          |+ - video engine
//			|+ - animator
//          |+ - animationPart
//			|+ - displayFlush
//  		|+ - displayResolution
//          |+ - bgColor
//          |+ - lastFrame
//          |+ - displayRate
//          + - FileManagement Lib
//          |+ - scanDrive
//          |+ - stream
//          |+ - write
//          |+ - read
//          |+ - flush
//          + Meta Lib
//          |+ - dump
//          |+ - decrypt
//          + Net Lib
//          |+ - scan_wifi
//          |+ - ack
//          |+ - interface
//          |+ - netconfig
//          |+ - toNetStr
//          |+ - addSession
//          |+ - closeSession
//          |+ - backSessions
//          |+ - connect
//          + Algo Lib
//          |+ - swap
//          |+ - compare
//          |+ - min
//          |+ - max
//          |+ - permute
//          + Encryption
//          |+ - rot13
//          |+ - caesar
//          |+ - byteSwap
//					+	Args
//					|+ - parse
//					|+ - dictionnary
// 					|+ - eval

//Loading dependencies in /lib
Libs = {}
Libs.metaxploit = "";
Libs.crypto = "";
Libs.aptclient = "";
Libs.libmail = "";
Libs.load_dependencies = function()
	libFolder = get_shell.host_computer.File("/lib");
	if typeof(libFolder) == "file" then
		files = libFolder.get_files;
		if files.len > 0 then
			for i in range(0,files.len -1)
				if files[i].name == "metaxploit.so" then
					Libs.metaxploit = include_lib(files[i].path);
				else if files[i].name == "crypto.so" then
					Libs.crypto = include_lib(files[i].path);
				else if files[i].name == "aptclient.so" then
					Libs.aptclient = include_lib(files[i].path);
				else if files[i].name == "libmail.so" then
					Libs.libmail = include_lib(files[i].path);
				end if
			end for
		end if
	end if
end function

//String header
String = {};
String.reserved_reverse_string = "";

//Reverse string.
//Simply reverse a string.
String.reverseString = function(x)
	if typeof(x) != "string" then return "error : reverse string -> x expected string.";
	string = [];
	for i in range(0,x.len -1)
		string.push(x[i]);
	end for
	string.reverse;
	String.reserved_reverse_string = string.join("");
	return String.reserved_reverse_string;
end function

//String to decimal.
//Simply convert a string to decimal.
String.stringToDecimal = function(x)
	if typeof(x) != "string" then return "error : string to decimal -> x expected string.";
	decString = "";
	for i in range(0,x.len -1)
		decString = decString + code(x[i]);
		if i < x.len -1 then decString = decString + ":";
	end for
	return decString;
end function

//String to hex.
//Simply convert a string to hex , using Math lib.
String.stringToHex = function(x)
	if typeof(x) != "string" then return "error : string to hex -> x expected string.";
	hexString = "";
	for i in range(0,x.len -1)
		hexString = hexString + Math.decimalToHex(code(x[i]),"");
		if i < x.len -1 then hexString = hexString + ":";
	end for
	return hexString;
end function

//String to list.
//Simply convert a string to a char list.
String.stringToList = function(x)
	if typeof(x) != "string" then return "error : string to list -> x expected string.";
	list = [];
	for i in range(0,x.len -1)
		list.push(x[i]);
	end for
	return list;
end function

String.cut = function(x,y)
	if typeof(x) != "string" then return "error : string cut -> x expected string.";
	if typeof(y) != "list" then return "error : string cut -> x expected string.";

	string = String.stringToList(x);
	part1 = [];
	part2 = [];
	for i in range(0,string.len -1)
		if i < y[0] then part1.push(string[i]);
		if i > y[1] then part2.push(string[i]);
	end for
	cutString = [part1.join(""),part2.join("")];

	return cutString;
end function

String.replace = function(x,y,z)
	if typeof(x) != "string" then return "error : string replace -> x expected string.";
	if typeof(y) != "list" then return "error : string replace -> y expected string.";
	if typeof(z) != "string" then return "error : string replace -> z expected string.";

	string = String.stringToList(x);
	part1 = [];
	part2 = [];

	for i in range(0,string.len -1)
		if i < y[0] then part1.push(string[i]);
		if i > y[1] then part2.push(string[i]);
	end for
	newString = part1.join("") + z + part2.join("");

	return newString;
end function

//Math Header
Math = {};
Math.reserved_hex_string = "";
Math.reserved_binary_string = "";

//Vectors 2d, 3d, 4d.
//Vectors are simple list.They act as holders, example given : the position of a point in a grid.
//Well used , they can speed up some processing in math.
Math.vector2 = function(x,y)
	if typeof(x) != "number" then return "error : vector2 -> x not a number.";
	if typeof(y) != "number" then return "error : vector2 -> y not a number.";
	return [x,y];
end function

Math.vector3 = function(x,y,z)
	if typeof(x) != "number" then return "error : vector3 -> x not a number.";
	if typeof(y) != "number" then return "error : vector3 -> y not a number.";
	if typeof(z) != "number" then return "error : vector3 -> z not a number.";
	return [x,y,z];
end function

Math.vector4 = function(x,y,z,w)
	if typeof(x) != "number" then return "error : vector4 -> x not a number.";
	if typeof(y) != "number" then return "error : vector4 -> y not a number.";
	if typeof(z) != "number" then return "error : vector4 -> z not a number.";
	if typeof(w) != "number" then return "error : vector4 -> w not a number.";
	return [x,y,z,w];
end function

//Decimal to hex converter.
//The function convert a decimal value to a hex into a given string.Example Math.decimalToHex(10,"") , will return the hex value of 10.
//Important: If you have a decimal string, remember that this function accept one decimal at the time.
Math.decimalToHex = function(x,z)
	if typeof(x) != "number" then return "error : decimal to hex -> x not number.";

	remainder = x% 16;
	sum = x / 16;
	hex = z;

	if remainder == 10 then remainder = "A";
	if remainder == 11 then remainder = "B";
	if remainder == 12 then remainder = "C";
	if remainder == 13 then remainder = "D";
	if remainder == 14 then remainder = "E";
	if remainder == 15 then remainder = "F";

	hex = hex + str(remainder);
	if str(sum).indexOf(char(46)) != null then
		sum = str(sum).split(char(46))[0].to_int;
	end if

	if sum > 0 then
		Math.decimalToHex(sum,hex);
	else
		Math.reserved_hex_string = String.reverseString(hex);
	end if
	return Math.reserved_hex_string;
end function

//Pourcent.
//This function simply return a pourcentage.
Math.pourcent = function(x,y)
	if typeof(x) != "number" then return "error : pourcent -> x expected int.";
	if typeof(x) != "number" then return "error : pourcent -> y expected int.";
	pourcent = (x/y) * 100;
	return pourcent;
end function

//Median.
//This function return the median element of a list.
Math.median = function(x)
	if typeof(x) != "list" then return "error : median -> x expected list.";
	n = x.len;
	median = x[(n + 1)/2];
	return median;
end function

//Average.
//This function return the average of a series of integer in a list.
Math.average = function(x)
	if typeof(x) != "list" then return "error : average -> x list expected.";
	sum = 0;
	elements = 0;
	for i in range(0,x.len -1)
		if typeof(x[i]) != "number" then return "error :  average -> x[i] expected integer.";
		sum = sum + x[i];
		elements = elements + 1;
	end for

	average = sum/elements;
	return average;
end function

//decimalToBinary
//This function convert a decimal to binary then return the result.It use the divided by 2 method.
Math.decimalToBinary = function(x,y)
	if typeof(x) != "number" then return "error : decimal to binary -> x int expected.";

	remainder = x% 2;
	sum = x / 2;
	binary = y;

	binary = binary + str(remainder);
	if str(sum).indexOf(char(46)) != null then
		sum = str(sum).split(char(46))[0].to_int;
	end if

	if sum == 1 or sum == 0 then
		if sum == 0 then binary = binary + "0";
		if sum == 1 then binary = binary + "1";
		Math.reserved_binary_string = String.reverseString(binary).to_int;
		return Math.reserved_binary_string;
	else
		//Here we put a special return cause its like that.No kidding, apparently
		//is due because its a recursive function.As the modo on discord say.Permit
		//me to doubt of it as decimal to hex function dont use it and return normaly.
		//Dont remove that return or it will bug.
		return Math.decimalToBinary(sum,binary);
	end if
end function

//Binary to decimal.
Math.binaryToDecimal = function(x)
	bin = str(x);
	sum = 0;
	for i in range(0,bin.len -1)
		sum = (sum * 2) + bin[i].to_int;
	end for
	return sum;
end function

//Graph header
Graph = {};
Graph.reserved_hex_tag = "";
Graph.reserved_video_buffer = {"queud":[],"lastFrame":""};
Graph.reserved_video_display = {"grid":[8,8],"content":[],"bg":"<mark=#000000>x</mark>","rate":0.6}; //default 8x8
Graph.reserved_video_switch = true;

//RGB.
//This function return the hex tag of the given rgb value, in a vector form.
//Exemple Graph.rgb(Math.vector3(135,22,55)) , this return the color to in hex format.
Graph.rgb = function(x)
	if typeof(x) != "list" then return "error : rgb -> x expected list.";
	if x.len != 3 then return "error : rgb -> x expected 3 len."
	hexTag = "";
	for i in range(0,x.len -1)
		if typeof(x[i]) != "number" then return "error : rgb -> x[i] not a number"
		hexTag = hexTag + Math.decimalToHex(x[i],"");
	end for

	if hexTag.len < 6 then
		hexTag = "#0" + hexTag;
	else
		hexTag = "#" + hexTag;
	end if

	Graph.reserved_hex_tag = hexTag;
	return Graph.reserved_hex_tag;
end function

//Color.
//This function return the given text enquote of <color=y> </color> tags, with the given hex colors.
Graph.color = function(x,y)
	color = "<color=" + y + ">" + x + "</color>";
	return color;
end function

//Size.
//This function return the given text enquote of <size=y> </size> tags, with the given size.
Graph.Size = function(x,y)
	if typeof(y) != "number" then return "error : size y not a number.";
	return "<size=" + y + ">" + x + "</size>";
end function

//Italic.
//This function return the given text enquote of <italic> </italic> tags.
Graph.italic = function(x)
	italic = "<i>" + x + "</i>";
	return italic;
end function

//Bold.
//This function return the given text enquote of <bold> </bold>.
Graph.bold = function(x)
	bold = "<b>" + x + "</b>";
	return bold;
end function

//Underline.
//This function return the text underlined.
Graph.underline = function(x)
	return "<u>" + x + "</u>";
end function

//drawLine.
//This function draw a line with the len according to the z value.
Graph.drawLine = function(x,y)
	if typeof(x) != "string" then return "error : draw line -> x expected string.";
	if typeof(y) != "number" then return "error : draw line -> y expected int.";
	for i in range(1,y)
		x = x + char(95);
	end for
	return Graph.underline(x) ;
end function

//align.
//This function align the text according to the y value.left , right & center
Graph.align = function(x,y)
	if y != "center" and y != "right" and y != "left" then return "error : align -> y expected left,right or center.";
	return "<align=" + y + ">" + x + "</align>";
end function

//spacing.
//This function space the text to the z value.
//Example Graph.spacing("text","1em");
Graph.spacing = function(x,y)
	return "<cspace=" + y + ">" + x + "</cspace>";
end function

//font.
//This function will apply the given font to the given text.
//Here some available font found:
//SourceCodePro-Regular SDF
//LiberationSans SDF
Graph.font = function(x,y)
	return "<font=" + y + ">" + x + "</font>";
end function

//Indent.
//This function return the text with indented.Y take the value as a pourcentage.
Graph.indent = function(x,y)
	return "<indent=" + y + ">" + x + "</indent>";
end function

//Margin.
//This function return the text with the value of z as margin.
Graph.margin = function(x,y)
	return "<margin=" + y + ">" + x + "</margin>";
end function

//Mark.
//This function return the text marked by the hex color of the z value.
Graph.mark = function(x,y)
	return "<mark=" + y + ">" + x + "</mark>";
end function

//Sprite.
//This function is mysterious return the sprite according the given id:int.
//Atm only index 0 as be found.What a mystery.
Graph.sprite = function(x)
	return "<sprite=" + x + ">";
end function

//Strike.
//This function strike the text and return it.
Graph.strike = function(x)
	return "<s>" + x + "</s>";
end function

//The video engine.
//The function manipulate a grid with black pixel in it.When you turn on a pixel.Dont forget to turn it off, if you dont want it appear in the next frame.
//Its the same for the grid dont forget to reinitialize the pixels example changing a scene.


Graph.videoEngine = function(buf,dis)
	clear_screen;
	while (Graph.reserved_video_buffer.queud.len != 0)
		if Graph.reserved_video_display.content.len == 0 then
			yaxis = [];
			for i in range(1,Graph.reserved_video_display.grid[0])
				xaxis = [];
				for e in range(1,Graph.reserved_video_display.grid[1])
					xaxis.push((Graph.reserved_video_display.bg));
				end for
				yaxis.push(xaxis);
			end for
			Graph.reserved_video_display.content = yaxis;
		end if

		Graph.reserved_video_display.content[Graph.reserved_video_buffer.queud[0].position[0] -1][Graph.reserved_video_buffer.queud[0].position[1] -1] = Graph.reserved_video_buffer.queud[0].value;
		frame = "";
		for i in range(0,Graph.reserved_video_display.content.len -1)
			for e in range(0,Graph.reserved_video_display.content[i].len -1)
				if Graph.reserved_video_display.content[i][e] == "" then Graph.reserved_video_display.content[i][e] = Graph.reserved_video_display.bg;
			end for
			frame = frame + char(10) + Graph.reserved_video_display.content[i].join("");
		end for
		if Graph.reserved_video_buffer.queud.len == 1 then
			Graph.reserved_video_buffer.lastFrame = frame;
			print(frame);
			wait(Graph.reserved_video_display.rate);
		end if
		Graph.reserved_video_buffer.queud.remove(0);
	end while
	return;
end function

//The animator play the given animation.
Graph.animator = function(x)
	for i in range(0,x.len -1)
		Graph.reserved_video_buffer.queud.push(x[i]);
	end for
	return Graph.videoEngine(Graph.reserved_video_buffer,Graph.reserved_video_display);
end function

//The animation part is the variable that store the data of the pixel in the grid.If the value of a
//pixel "" then the pixel become a black pixel.
Graph.animationPart = function(x,y)
	if typeof(x) != "string" then return "error : animation part -> x expected string.";
	if typeof(y) != "list" then return "error : animation part -> y expected number.";
	animationString = {};
	animationString.value = x;
	animationString.position = y;
	return animationString;
end function

//display flush, reset all pixels in the grid.
Graph.displayFlush = function()
	Graph.reserved_video_display.content = [];
	return;
end function

//The function set the default grid color, named background.
Graph.bgColor = function(x)
	Graph.reserved_video_display.bg = "<mark=" + x + ">x</mark>";
	return;
end function

//display resolution change the size of the grid , by default its 8*8.
Graph.displayResolution = function(x,y)
	if typeof(x) != "number" then return "error : display resolution -> x expected number.";
	if typeof(y) != "number" then return "error : display resolution -> y expected number.";
	Graph.reserved_video_display.grid[0] = x;
	Graph.reserved_video_display.grid[1] = y;
	return;
end function

//return the last frame processed.
Graph.lastFrame = function()
	return Graph.reserved_video_buffer.lastFrame;
end function

//Set the wait rate , default 0.6.
Graph.displayRate = function(x)
	if typeof(x) != "number" then return "error : display rate -> x expected number.";
	return Graph.reserved_video_display.rate(x);
end function

//FileSystem header

FileSystem = {};
FileSystem.reserved_stream = {"read":false,"write":false,"file":""};

FileSystem.stream = function(x,y)
	if FileSystem.reserved_stream.read == false and FileSystem.reserved_stream.write == false then
		if x == "out" then FileSystem.reserved_stream.write = true;
		if x == "in" then FileSystem.reserved_stream.read = true;
		if FileSystem.reserved_stream.read == false and FileSystem.reserved_stream.write == false then return "error : stream unknown type , available in or out.";
		FileSystem.reserved_stream.file = get_shell.host_computer.File(y);
		if typeof(FileSystem.reserved_stream.file) != "file" then
			if y.indexOf(char(47)) == null then
				get_shell.host_computer.touch(current_path,y);
			else
				directory = "/" + y.split(char(47))[1:y.split(char(47)).len - 1].join(char(47));
				filename = y.split(char(47))[y.split(char(47)).len - 1];
				get_shell.host_computer.touch(directory,filename);
			end if
			if typeof(get_shell.host_computer.File(y)) != "file" then return "error : stream file -> y was unable to create the file.";
			if typeof(get_shell.host_computer.File(y)) == "file" then FileSystem.reserved_stream.file = get_shell.host_computer.File(y);
		end if
		return;
	else
		return "Buffer in use.";
	end if
end function

//Write.
//This function is used to write on the current stream.By this mean a out stream should be opened.
FileSystem.write = function(x)
	if FileSystem.reserved_stream.write == true then
		if typeof(FileSystem.reserved_stream.file) != "file" then return "error : write -> file not exist";
		FileSystem.reserved_stream.file.set_content(x);
		return;
	else
		return "Buffer currently closed.";
	end if
end function

//Read.
//This function is used to read the content of a in stream.
FileSystem.read = function()
	if FileSystem.reserved_stream.read == true then
		if typeof(FileSystem.reserved_stream.file) != "file" then return "error : write -> file not exist";
		return FileSystem.reserved_stream.file.get_content;
	else
		return "Buffer currently closed.";
	end if
end function

//Flush.
//This function close the stream.
//Important: Only one stream can live at the time.
FileSystem.flush = function()
	FileSystem.reserved_stream.read = false;
	FileSystem.reserved_stream.write = false;
	FileSystem.reserved_stream.file = "";
end function

//Meta header

Meta = {};

//Dump
//This function scan the lib at the given addrs/port and return all the mems and cve into list.
Meta.dump = function(x,y)
	if typeof(y) != "number" then return "error : dump -> y expected number.";
	target = Libs.metaxploit.net_use(x,y);
	if typeof(target) != "NetSession" then return "error : dump -> net session failed.";
	if typeof(Libs.metaxploit) != "MetaxploitLib" then return "error : dump metaxploit not found in /lib";
	target_lib = target.dump_lib;
	target_scan = Libs.metaxploit.scan(target_lib);
	target_exploits = [];
	for i in range(0,target_scan.len -1)
		target_exploits.push({"mem":target_scan[i],"cve":Libs.metaxploit.scan_address(target_lib,target_scan[i])});
	end for
	return target_exploits;
end function

//Decrypt
//This function try to decrypt a given user:pass hash format.Example Meta.decrypt("user:hash") , this will return the pass is it succeed.
Meta.decrypt = function(x)
	password = Libs.crypto.decipher(x.split(char(58))[1]);
	return password;
end function

//Net header

Net = {};
Net.reserved_backsession = [];

//Scan wifi.
//This function scan the wifi on the given interface and store in a list.
Net.scan_wifi = function(x)
	networks = get_shell.host_computer.wifi_networks(x);
	return networks;
end function

//Ack
//This function capture packets of the given wifi.It take 3 arguments as a single string.Example Net.Ack("bssid,essid,maxAck").
Net.ack = function(x)
	bid = x.split(char(44))[0];
	eid = x.split(char(44))[1];
	ack = x.split(char(44))[2].to_int;
	Libs.crypto.aireplay(bid,eid,ack);
end function

//Interface.
//This function work the same as crypto.airmon, its theres for aestetic.
Net.interface = function(x,y)
	return Libs.crypto.airmon(x,y);
end function

//NetConfig
//This function return info in a list about the current network information.
Net.netconfig = function()
	config = [get_router.essid_name,get_router.bssid_name,get_shell.host_computer.network_gateway,get_shell.host_computer.local_ip,get_shell.host_computer.public_ip,whois(get_shell.host_computer.public_ip)];
	return config;
end function

//toNetStr.
//This function is used to convert a single element of a list returned by scan_wifi.
//You can always make it manualy.
Net.toNetStr = function(x,y)
	data = x.split(char(32));
	if data.len != 3 then return "error : net to string -> x the string format is not recognized.";
	bid = data[0];
	eid = data[2];
	ack = y;
	netString = bid + "," + eid + "," + ack;
	return netString;
end function

//addSession.
//This function allow you to background a network session.It store it in a list as a network object.
//Note: The session set is design to let the user having multiple sessions from one point.Like this
//You can free up space in coding using one main variable to create connection
//.It is also useful to create dynamic connections bot etc.You can also used
//Net.connect(ip,user,port,pass) like connect_service. Net.connect will do all the work for you, aswell
//removing the initial var.The only thing need if Net.connect is used , is to catch the session
//from the backsession function.By iterating trough the data of the elements you will find your
//connection.
Net.addSession = function(x)
	if typeof(x) != "shell" then return "error : background session -> x shell expected.";
	session = new {};
	session.ip = x.host_computer.public_ip;
	session.lan = x.host_computer.local_ip;
	session.gateway = get_router(x.host_computer.public_ip).local_ip;
	session.shell = x;
	session.id = Net.reserved_backsession.len ;
	Net.reserved_backsession.push(session);
	return;
end function

//closeSession.
//This function allow you to close a background session.
Net.closeSession = function(x)
	if typeof(x) != "number" then return "error : close session -> x int expected.";
	Net.reserved_backsession.remove(x);
	return;
end function

//backsession.
//This function return all the backgroundSession list.
Net.backsessions = function()
	return Net.reserved_backsession;
end function

//connect.
//This function is used to connect to various service.The connection is stored in backsession and are accessible in backsession function.
//Net.connect(ip,port,user,pass);
//Note if the connection fail, it will not appear in the backgroundSession list as no connection occured.
Net.connect = function(x,y,z,w)
	if typeof(y) != "number" then return "error : connect -> y int expected";
	Net.addSession(get_shell.connect_service(x,y,z,w));
	return;
end function

//Algo header

Algo = {};

//This function is used to swap to values in a list of size two.
Algo.swap =  function(x)
	if typeof(x) != "list" then return "error : swap -> x list expected.";
	if x.len != 2 then return "error : swap -> x len 2 expected.";
	a = x[0];
	b = x[1];
	x[0] = b;
	x[1] = a;
	return x;
end function

//Compare.
//The compare function is use to know if x > or < or == y.
Algo.compare = function(x,y)
	if x > y then return ">"; //62
	if x < y then return "<"; //60
	if x == y then return "=="; //61
end function

//Max.
//This function is used to know the max of two given values.
Algo.max = function(x)
	if typeof(x) != "list" then return "error : max -> x list expected."
	if x.len != 2 then return "error : max -> x len 2 expected."
	if typeof(x[0]) == "number" and typeof(x[1]) == "number" then
		max = Algo.compare(x[0],x[1]);
		if max == ">" or max == "==" then return x[0];
		if max == "<" then return x[1];
	else if typeof(x[0]) == "string" and typeof(x[1]) == "number" then
		max = Algo.compare(code(x[0]),x[1]);
		if max == ">" or max == "==" then return x[0];
		if max == "<" then return x[1];
	else if typeof(x[0]) == "number" and typeof(x[1]) == "string" then
		max = Algo.compare(x[0],code(x[1]));
		if max == ">" or max == "==" then return x[0];
		if max == "<" then return x[1];
	else if typeof(x[0]) == "string" and typeof(x[1]) == "string" then
		max = Algo.compare(code(x[0]),code(x[1]));
		if max == ">" or max == "==" then return x[0];
		if max == "<" then return x[1];
	end if
	return;
end function

//Min.
//This function is used to know the min of two given valuess.
Algo.min = function(x)
	if typeof(x) != "list" then return "error : min -> x list expected.";
	if x.len != 2 then return "error : min -> x len 2 expected.";
	if typeof(x[0]) == "number" and typeof(x[1]) == "number" then
		min = Algo.compare(x[0],x[1]);
		if min == ">" or min == "==" then return x[1];
		if min == "<" then return x[0];
	else if typeof(x[0]) == "string" and typeof(x[1]) == "number" then
		min = Algo.compare(code(x[0]),x[1]);
		if min == ">" or min == "==" then return x[1];
		if min == "<" then return x[0];
	else if typeof(x[0]) == "number" and typeof(x[1]) == "string" then
		min = Algo.compare(x[0],code(x[1]));
		if min == ">" or min == "==" then return x[1];
		if min == "<" then return x[0];
	else if typeof(x[0]) == "string" and typeof(x[1]) == "string" then
		min = Algo.compare(code(x[0]),code(x[1]));
		if min == ">" or min == "==" then return x[1];
		if min == "<" then return x[0];
	end if
	return;
end function

//Permute.
//This function is used to permute strings.
Algo.permute = function(x,y);
	if typeof(x) != "string" then return "error : permute -> x string expected.";
	if typeof(y) != "list" then return "error : permute -> y list expected.";

	s0 = String.stringToList(x);
	s1 = s0[0];
	s2 = s0[1:s0.len].join("");

	swap = Algo.swap([s1,s2]).join("");
	revs = String.reverseString(swap);

	y.push(swap);
	y.push(revs);

	if y.indexOf(y[0],1) != null then return y[1:y.len -1];
	if y.indexOf(y[0],1) == null then return Algo.permute(swap,y);
end function

Encryption = {}

//Encryption and decrypt rot13.
Encryption.rot13 = function(x)
	chars = String.stringToList(x);
	for i in range(0,chars.len -1)
		if code(chars[i]) >= 65 and code(chars[i]) <= 90 then
			chars[i] = char(65 + (code(chars[i]) - 65+13)%26);
		else if code(chars[i]) >= 97 and code(chars[i]) <= 122 then
			chars[i] = char(97 + (code(chars[i]) - 97+13)%26);
		end if
	end for
	return chars.join("");
end function

//Encryption and decrypt caesar.
Encryption.caesar = function(x,y)
	chars = String.stringToList(x);
	for i in range(0,chars.len -1)
		if code(chars[i]) >= 65 and code(chars[i]) <= 90 then
			chars[i] = char(65 + (code(chars[i]) - 65+y)%26);
		else if code(chars[i]) >= 97 and code(chars[i]) <= 122 then
			chars[i] = char(97 + (code(chars[i]) - 97+y)%26);
		end if
	end for
	return chars.join("");
end function

//Encryption and decrypt byte swap.
Encryption.byteSwap = function(x)
	byteString = String.stringToDecimal(x);
	bytes = [];

	byte = "";
	for i in  range(0,byteString.len -1)
		if byteString[i] == ":" then
			bin = Math.decimalToBinary(byte.to_int,"");
			bytes.push(bin);
			byte = "";
		else
			byte = byte + byteString[i];
			if i == byteString.len -1 then
				bin = Math.decimalToBinary(byte.to_int,"");
				bytes.push(bin);
				byte = "";
			end if
		end if
	end for

	for i in range(0,bytes.len -1)
		byte = str(bytes[i]);
		if byte.len < 7 then
			bytes[i] = "00" + str(byte);
		else if byte.len == 7 then
			bytes[i] = "0" + str(byte);
		end if
	end for

	for i in range(0,bytes.len -1)
		bin = [];
		set = "";
		for e in range(0,str(bytes[i]).len -1)
			set = set + str(bytes[i])[e];
			if set.len == 2 then
				newByte = Algo.swap([set[0],set[1]]);
				newByte = newByte[0] + newByte[1];
				bin.push(newByte);
				set = "";
			end if

			if e == str(bytes[i]).len -1 then
				bytes[i] = bin.join("");
			end if
		end for
	end for

	decString = [];
	for i in range(0,bytes.len -1)
		decString.push(Math.binaryToDecimal(bytes[i]));
	end for

	string = ""
	for i in range(0,decString.len -1)
		string = string + char(decString[i]);
	end for

	return string;
end function

//Args Libs

Args = {};

//The args dictionnary function, return a map of the available
//commands.The list is stored in '/usr/bin/mol/args.dict'.You
//have to program yourself the creation of the folder and file.
//This is the template of the return : [{"arg":"arg1","childs":1},...].
Args.dictionnary = function(dictpath)
  config = get_shell.host_computer.File(dictpath);
  if typeof(config) != "file" then return "Could not read -> '" + dictpath + "' eval(file)";
  if config.get_content.len < 1 then return false;

  //arg1-2 -> e.g "mycommand -args1 1 2"
  data = config.get_content.split(";");
  elements = [];

  for i in range(0,data.len -1)
    argstring = data[i].split("-");
    if argstring.len != 2 then return str("Could not parse -> " + argstring.join("") + " in eval(list)");
    if typeof(argstring[1].to_int) != "number" then str("Could not parse -> " + argstring[1].join("") + " : eval(number)");
    arg = "-" + argstring[0];
    argchilds = argstring[1];
    elements.push({"arg":arg,"childs":argchilds.to_int});
  end for

  return elements;
end function

//The eval function is use to evaluate if a parameter is
//Invalid or not.It is designed to work with "args.parse()".
//It use a cmap "command map".Look at args.parse to know more.
Args.eval = function(cmap)
  isValid = false;
  errors = [];
  for i in range(0,cmap.len -1)
    for e in range(0,Args.dictionnary.len -1)
      template = Args.dictionnary[e];
      command = cmap[i];

      if template.arg == command.arg then
        if template.childs == command.childs.len then
          isValid = true;
          break;
        end if
      end if

    end for

    if isValid == true then
      isValid = false;
    else
      errors.push(str("args.eval(invalid parameter : + " + cmap[i].arg + ")"));
    end if
  end for
  if errors.len > 0 then return errors;
  if errors.len == 0 then return true;
end function

//Arg.parse is use to parse param map and evaluate if the
//command passed is good or not.If the command fail the evaluation
//the function will return a errors list with each error leaving
//your plenty power on the output.In the other side if the commands
//pass the evaluation the function will return map with each parameter
//and their option(child).Here the template of the map when it pass then
//evaluation : [{"arg":"arg1","child":["1","2"]}].
Args.parse = function(command)
  cmap = [];

  //building the received line into a index map.
  command = command.split(" ");
  for i in range(0,command.len -1)
    if command[i][0] == "-" then
      map = {"arg":command[i],"childs":[]};
      for e in range(i,command.len -1)
        if e != i then
          if command[e][0] == "-" then break;
          map.childs.push(command[e]);
        end if
      end for
      cmap.push(map);
    end if
  end for

  //looking if theres error in the command line received by using
  //a dictionnary of templates.
  evaluation = args.eval(cmap);
	if cmap.len == 0 then return "unrecognize input.";
  if evaluation == true then return cmap;
  return evaluation;
end function

//Language header.
Language = {};
Language.localization = function(locapath)
	config = get_shell.host_computer.File(locapath);
	if typeof(config) != "file" then return "Could not read '" + locapath + "' eval(file)";
	if config.get_content.len < 0 then return false;

	//Getting the localizators - example of a peace of file format.
	//spanish;french;english;myowninvented
	//juego;jeu;game;engio
	//krita;kri;krite;fwer

	data = config.get_content.split(char(10));
	print(data);
	localizators = data[0].split(";");
	if localizators.len < 1 then return false;

	dict = [];

	for i in range(1,data.len -1)
		//get the variant string - 'juego;jeu;game;engio'
		variant_string = data[i].split(";");
		if data[i].len < 1 then return false;

		//if the variant string contain only the tag
		//then add undefined value for each localizators
		if data[i].len == 1 then
			for e in range(0,localizators.len -1)
				variant_string.push("undefined");
			end for
		end if

		//assemble the dictionnary
		map = {"word":variant_string[0],"dict":[]};

		for e in range(0,variant_string.len -1)
				if e > localizators.len then return "Cannot parse -> '" + dictpath + "' eval(file)";
				map.dict.push({localizators[e]:variant_string[e]});
		end for

		dict.push(map);
	end for

	return dict;
end function

Language.trad = function(wor,lan,dic)
	for i in range(0,dic.len -1)
		if dic[i].word == wor then
			for e in range(0,dic[i].dict.len -1)
				map = dic[i].dict[e];
				if map.hasIndex(lan) == true then
					return map[lan];
				end if
			end for
		end if
	end for
	return "undefined.";
end function
